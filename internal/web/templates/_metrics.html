<div class="card" id="metrics-card">
    <header class="card-header is-flex is-flex-wrap-wrap">
        <p class="card-header-title has-text-centered">Node Metrics</p>
        <div class="card-header-icon is-flex-grow-1 is-flex is-justify-content-flex-end">
            <div class="dropdown" id="dateRangeDropdown">
                <div class="dropdown-trigger">
                    <button class="button" aria-haspopup="true" aria-controls="dropdown-menu" id="dateRangeButton">
                        <span id="dateRangeText">Select date range</span>
                        <span class="icon is-small">
                            <i class="fas fa-angle-down" aria-hidden="true"></i>
                        </span>
                    </button>
                </div>
                <div class="dropdown-menu" id="dropdown-menu" role="menu">
                    <div class="dropdown-content">
                        <a href="#" class="dropdown-item" data-range="30m">Last 30 minutes</a>
                        <a href="#" class="dropdown-item" data-range="1h">Last 1 hour</a>
                        <a href="#" class="dropdown-item" data-range="3h">Last 3 hours</a>
                        <a href="#" class="dropdown-item" data-range="6h">Last 6 hours</a>
                        <a href="#" class="dropdown-item" data-range="12h">Last 12 hours</a>
                        <a href="#" class="dropdown-item" data-range="24h">Last 24 hours</a>
                        <a href="#" class="dropdown-item" data-range="7d">Last 7 days</a>
                        <hr class="dropdown-divider" />
                        <a href="#" class="dropdown-item" id="dateRangeInput">Select date range</a>
                    </div>
                </div>
            </div>
            <button id="refreshButton" class="button ml-2">
                <span class="icon">
                    <i class="fas fa-sync-alt"></i>
                </span>
                <span>Auto Refresh</span>
            </button>
        </div>
    </header>
    <div class="card-content">
        <div class="content">
            <div class="columns is-multiline">
                <div class="column is-4">
                    <canvas id="cpuChart"></canvas>
                </div>
                <div class="column is-4">
                    <canvas id="memoryChart"></canvas>
                </div>
                <div class="column is-4">
                    <canvas id="diskChart"></canvas>
                </div>

                <div class="column is-12">
                    <canvas id="networkChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    <script>
        $(document).ready(async function () {
            // Constants
            const API_BASE_URL = '/api/v1';
            const NODE_METRICS_PATH = '/node_metrics/';
            const BYTE_TO_MB = 1024 * 1024;
            const BYTE_TO_GB = BYTE_TO_MB * 1024;

            // Utility functions
            const handleError = (error) => {
                console.error('Error:', error);
                // You can add user notifications here
            };

            const formatDate = (timeStamp) => {
                const date = new Date(timeStamp * 1000);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            };

            const formatBytes = (bytes, decimals = 2) => {
                return (bytes / BYTE_TO_GB).toFixed(decimals);
            };

            // API functions
            const fetchData = async (path, params = {}) => {
                const url = new URL(API_BASE_URL + path, window.location.origin);
                $.each(params, (key, value) => url.searchParams.append(key, value));
                try {
                    const response = await $.ajax({
                        url: url.toString(),
                        method: 'GET',
                        dataType: 'json',
                    });
                    return response;
                } catch (error) {
                    handleError(error);
                    return null;
                }
            };

            const fetchLatestMetric = () => fetchData(NODE_METRICS_PATH, { latest: true }).then((data) => data?.data[0]);
            const fetchMetrics = (startTs, endTs) =>
                fetchData(NODE_METRICS_PATH, { start_ts: startTs, end_ts: endTs }).then((data) => data?.data);

            // Chart functions
            const initChart = (canvasId, type, datasets, legendPosition = '', yDisplayText = '', title = '', unit = '') => {
                const ctx = $(`#${canvasId}`)[0].getContext('2d');
                const colors = {
                    cpu: 'rgba(255, 99, 132, 1)',
                    memory: 'rgba(54, 162, 235, 1)',
                    disk: 'rgba(255, 206, 86, 1)',
                    receive: 'rgba(0, 150, 255, 1)',
                    transmit: 'rgba(255, 140, 0, 1)',
                };

                const getDatasetConfig = (label) => {
                    const color = colors[label.toLowerCase()] || 'rgba(0, 0, 0, 1)'; // 默认颜色
                    console.log(label, color);
                    return {
                        label,
                        borderColor: color,
                        backgroundColor: color.replace('1)', '0.2)'),
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: true,
                        data: [],
                    };
                };

                const data = {
                    labels: [],
                    datasets: $.isArray(datasets)
                        ? datasets.map((dataset) => getDatasetConfig(dataset.label))
                        : [getDatasetConfig(datasets.label)],
                };

                return new Chart(ctx, {
                    type,
                    data,
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { position: legendPosition },
                            title: {
                                display: !!title,
                                text: title,
                                position: 'bottom',
                                font: { size: 14, weight: 'bold' },
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2) + ' ' + unit;
                                        }
                                        return label;
                                    },
                                },
                            },
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: yDisplayText, font: { weight: 'bold' } },
                            },
                            x: {
                                ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 },
                            },
                        },
                        elements: { line: { tension: 0.4 } },
                        downsample: {
                            enabled: true,
                            threshold: 200,
                        },
                    },
                });
            };

            const updateChart = (chart, newData, labels) => {
                if (!newData || !labels) {
                    console.error('Invalid data or labels provided');
                    return;
                }

                const formattedLabels = labels.map(formatDate);

                if ($.isArray(newData) && $.isArray(newData[0])) {
                    $.each(chart.data.datasets, (index, dataset) => {
                        if (newData[index]) {
                            dataset.data = newData[index];
                        }
                    });
                } else {
                    chart.data.datasets[0].data = newData;
                }

                chart.data.labels = formattedLabels;
                chart.update();
            };

            const updateCharts = (charts, metrics) => {
                console.log('Raw metrics data:', metrics);
                const timestamps = metrics.map((data) => data.timestamp);
                updateChart(
                    charts.cpu,
                    metrics.map((data) => data.cpu_usage),
                    timestamps,
                );
                updateChart(
                    charts.memory,
                    metrics.map((data) => data.memory_usage),
                    timestamps,
                );
                updateChart(
                    charts.disk,
                    metrics.map((data) => data.disk_usage),
                    timestamps,
                );
                updateChart(
                    charts.network,
                    [metrics.map((data) => data.network_in / BYTE_TO_MB), metrics.map((data) => data.network_out / BYTE_TO_MB)],
                    timestamps,
                );
            };

            const addLatestDataToCharts = (charts, latestMetric) => {
                console.log('Raw latestMetric data:', latestMetric);
                const timestamp = formatDate(latestMetric.timestamp);
                $.each(charts, (key, chart) => {
                    chart.data.labels.push(timestamp);
                    if (key === 'network') {
                        chart.data.datasets[0].data.push(latestMetric.network_in / BYTE_TO_MB);
                        chart.data.datasets[1].data.push(latestMetric.network_out / BYTE_TO_MB);
                    } else {
                        chart.data.datasets[0].data.push(latestMetric[`${key}_usage`]);
                    }
                    chart.update();
                });
            };

            // Chart initialization
            const initializeCharts = async () => {
                const metric = await fetchLatestMetric();
                if (!metric) return null;
                return {
                    cpu: initChart('cpuChart', 'line', { label: 'CPU' }, 'top', 'Usage (%)', `CPU`, '%'),
                    memory: initChart('memoryChart', 'line', { label: 'Memory' }, 'top', 'Usage (%)', `Memory`, '%'),
                    disk: initChart('diskChart', 'line', { label: 'Disk' }, 'top', 'Usage (%)', `Disk`, '%'),
                    network: initChart(
                        'networkChart',
                        'line',
                        [{ label: 'Receive' }, { label: 'Transmit' }],
                        'top',
                        'Rate (MB/s)',
                        'Network Rate',
                        'MB/s',
                    ),
                };
            };

            // Date range functions
            const setupDateRangeDropdown = (charts) => {
                const $dateRangeDropdown = $('#dateRangeDropdown');
                const $dateRangeButton = $('#dateRangeButton');
                const $dateRangeText = $('#dateRangeText');
                const $dateRangeInput = $('#dateRangeInput');

                $dateRangeDropdown.find('.dropdown-item[data-range]').on('click', function (e) {
                    e.preventDefault();
                    const range = $(this).data('range');
                    const now = new Date();
                    let start, end;
                    switch (range) {
                        case '30m':
                            start = new Date(now - 30 * 60 * 1000);
                            break;
                        case '1h':
                            start = new Date(now - 60 * 60 * 1000);
                            break;
                        case '3h':
                            start = new Date(now - 3 * 60 * 60 * 1000);
                            break;
                        case '6h':
                            start = new Date(now - 6 * 60 * 60 * 1000);
                            break;
                        case '12h':
                            start = new Date(now - 12 * 60 * 60 * 1000);
                            break;
                        case '24h':
                            start = new Date(now - 24 * 60 * 60 * 1000);
                            break;
                        case '7d':
                            start = new Date(now - 7 * 24 * 60 * 60 * 1000);
                            break;
                    }
                    end = now;

                    const startTs = Math.floor(start.getTime() / 1000);
                    const endTs = Math.floor(end.getTime() / 1000);
                    fetchDataForRange(charts, startTs, endTs);
                    $dateRangeText.text($(this).text());
                    $dateRangeDropdown.removeClass('is-active');
                });

                $dateRangeButton.on('click', (event) => {
                    event.stopPropagation();
                    $dateRangeDropdown.toggleClass('is-active');
                });

                $(document).on('click', (event) => {
                    if (!$dateRangeDropdown.has(event.target).length) {
                        $dateRangeDropdown.removeClass('is-active');
                    }
                });

                const picker = flatpickr($dateRangeInput[0], {
                    mode: 'range',
                    enableTime: true,
                    dateFormat: 'Y-m-d H:i',
                    onChange: function (selectedDates) {
                        if (selectedDates.length === 2) {
                            const startTs = Math.floor(selectedDates[0].getTime() / 1000);
                            const endTs = Math.floor(selectedDates[1].getTime() / 1000);
                            fetchDataForRange(charts, startTs, endTs);

                            const formattedStart = selectedDates[0].toLocaleString();
                            const formattedEnd = selectedDates[1].toLocaleString();
                            $dateRangeText.text(`${formattedStart} - ${formattedEnd}`);
                        }
                    },
                });
            };
            const fetchDataForRange = async (charts, startTs, endTs) => {
                const metrics = await fetchMetrics(startTs, endTs);
                if (metrics) {
                    console.log('Raw metrics data:', metrics);
                    updateCharts(charts, metrics);
                }
            };

            // Auto refresh functions
            const setupAutoRefresh = (charts) => {
                let autoRefreshInterval;
                let isAutoRefreshing = false;
                $('#refreshButton').click(function () {
                    if (isAutoRefreshing) {
                        clearInterval(autoRefreshInterval);
                        $(this).removeClass('is-info');
                        $(this).find('span:last').text('Auto Refresh');
                        isAutoRefreshing = false;
                    } else {
                        $(this).addClass('is-info');
                        $(this).find('span:last').text('Stop Refresh');
                        isAutoRefreshing = true;
                        refreshData(charts);
                        autoRefreshInterval = setInterval(() => refreshData(charts), 5000);
                    }
                });
            };

            const refreshData = async (charts) => {
                const latestMetric = await fetchLatestMetric();
                if (latestMetric) {
                    addLatestDataToCharts(charts, latestMetric);
                }
            };

            // Main execution
            const charts = await initializeCharts();
            if (charts) {
                setupDateRangeDropdown(charts);
                setupAutoRefresh(charts);
            }
        });
    </script>
</div>
