<div class="card" id="metrics-card">
    <header class="card-header is-flex is-flex-wrap-wrap">
        <p class="card-header-title has-text-centered">Node Metrics</p>
        <div class="card-header-icon is-flex-grow-1 is-flex is-justify-content-flex-end">
            <div class="dropdown is-hoverable">
                <div class="dropdown-trigger">
                    <button class="button" aria-haspopup="true" aria-controls="dropdown-menu">
                        <span class="icon">
                            <i class="fas fa-clock"></i>
                        </span>
                        <span>Time</span>
                        <span class="icon is-small">
                            <i class="fas fa-angle-down" aria-hidden="true"></i>
                        </span>
                    </button>
                </div>
                <div class="dropdown-menu" id="dropdown-menu" role="menu">
                    <div class="dropdown-content">
                        <a href="#" class="dropdown-item" data-time="15min">Last 15 Min</a>
                        <a href="#" class="dropdown-item" data-time="30min">Last 30 Min</a>
                        <a href="#" class="dropdown-item" data-time="1h">Last 1 hour</a>
                        <a href="#" class="dropdown-item" data-time="6h">Last 6 hours</a>
                        <a href="#" class="dropdown-item" data-time="12h">Last 12 hours</a>
                        <a href="#" class="dropdown-item" data-time="24h">Last 24 hours</a>
                    </div>
                </div>
            </div>
            <button id="refreshButton" class="button ml-2">
                <span class="icon">
                    <i class="fas fa-sync-alt"></i>
                </span>
                <span>Auto Refresh</span>
            </button>
        </div>
    </header>
    <div class="card-content">
        <div class="content">
            <div class="columns is-multiline">
                <div class="column is-4">
                    <canvas id="cpuChart"></canvas>
                </div>
                <div class="column is-4">
                    <canvas id="memoryChart"></canvas>
                </div>
                <div class="column is-4">
                    <canvas id="diskChart"></canvas>
                </div>

                <div class="column is-12">
                    <canvas id="networkChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const API_BASE_URL = '/api/v1';
        const NODE_METRICS_PATH = '/node_metrics/';
        const BYTE_TO_MB = 1024 * 1024;
        const BYTE_TO_GB = BYTE_TO_MB * 1024;

        // Utility functions
        const handleError = (error) => {
            console.error('Error:', error);
            // You can add user notifications here
        };

        const formatDate = (timeStamp) => {
            const date = new Date(timeStamp * 1000);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        };

        const formatBytes = (bytes, decimals = 2) => {
            return (bytes / BYTE_TO_GB).toFixed(decimals);
        };

        // API functions
        const fetchData = async (path, params = {}) => {
            const url = new URL(API_BASE_URL + path, window.location.origin);
            Object.keys(params).forEach((key) => url.searchParams.append(key, params[key]));
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Network response was not ok');
                return await response.json();
            } catch (error) {
                handleError(error);
                return null;
            }
        };

        const fetchLatestMetric = () => fetchData(NODE_METRICS_PATH, { latest: true }).then((data) => data?.data[0]);
        const fetchMetrics = (timeRange) => fetchData(NODE_METRICS_PATH, { time_range: timeRange }).then((data) => data?.data);

        // Chart functions
        const initChart = (canvasId, type, datasets, legendPosition = '', yDisplayText = '', title = '', unit = '') => {
            const ctx = document.getElementById(canvasId).getContext('2d');
            const colors = {
                cpu: 'rgba(255, 99, 132, 1)', // 红色
                memory: 'rgba(54, 162, 235, 1)', // 蓝色
                disk: 'rgba(255, 206, 86, 1)', // 黄色
                networkIn: 'rgba(75, 192, 192, 1)', // 青色
                networkOut: 'rgba(153, 102, 255, 1)', // 紫色
            };

            const getDatasetConfig = (label) => {
                let color;
                switch (label.toLowerCase()) {
                    case 'cpu':
                        color = colors.cpu;
                        break;
                    case 'memory':
                        color = colors.memory;
                        break;
                    case 'disk':
                        color = colors.disk;
                        break;
                    case 'receive':
                        color = colors.networkIn;
                        break;
                    case 'transmit':
                        color = colors.networkOut;
                        break;
                    default:
                        color = 'rgba(0, 0, 0, 1)';
                }

                return {
                    label,
                    borderColor: color,
                    backgroundColor: color.replace('1)', '0.2)'),
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: true,
                };
            };

            const data = {
                labels: [],
                datasets: Array.isArray(datasets)
                    ? datasets.map((dataset) => ({ ...getDatasetConfig(dataset.label), data: [] }))
                    : [{ ...getDatasetConfig(datasets.label), data: [] }],
            };

            return new Chart(ctx, {
                type,
                data,
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: legendPosition },
                        title: {
                            display: !!title,
                            text: title,
                            position: 'bottom',
                            font: { size: 14, weight: 'bold' },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2) + ' ' + unit;
                                    }
                                    return label;
                                },
                            },
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: yDisplayText, font: { weight: 'bold' } },
                        },
                        x: {
                            ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 },
                        },
                    },
                    elements: { line: { tension: 0.4 } },
                    downsample: {
                        enabled: true,
                        threshold: 200,
                    },
                },
            });
        };

        const updateChart = (chart, newData, labels) => {
            if (!newData || !labels) {
                console.error('Invalid data or labels provided');
                return;
            }

            const formattedLabels = labels.map(formatDate);

            if (Array.isArray(newData) && Array.isArray(newData[0])) {
                chart.data.datasets.forEach((dataset, index) => {
                    if (newData[index]) {
                        dataset.data = newData[index];
                    }
                });
            } else {
                chart.data.datasets[0].data = newData;
            }

            chart.data.labels = formattedLabels;
            chart.update();
        };

        const updateCharts = (charts, metrics) => {
            console.log('Raw metrics data:', metrics);
            const timestamps = metrics.map((data) => data.timestamp);
            updateChart(
                charts.cpu,
                metrics.map((data) => data.cpu_usage),
                timestamps,
            );
            updateChart(
                charts.memory,
                metrics.map((data) => data.memory_usage),
                timestamps,
            );
            updateChart(
                charts.disk,
                metrics.map((data) => data.disk_usage),
                timestamps,
            );
            updateChart(
                charts.network,
                [metrics.map((data) => data.network_in / BYTE_TO_MB), metrics.map((data) => data.network_out / BYTE_TO_MB)],
                timestamps,
            );
        };

        const addLatestDataToCharts = (charts, latestMetric) => {
            console.log('Raw latestMetric data:', latestMetric);
            const timestamp = formatDate(latestMetric.timestamp);
            Object.entries(charts).forEach(([key, chart]) => {
                chart.data.labels.push(timestamp);
                if (key === 'network') {
                    chart.data.datasets[0].data.push(latestMetric.network_in / BYTE_TO_MB);
                    chart.data.datasets[1].data.push(latestMetric.network_out / BYTE_TO_MB);
                } else {
                    chart.data.datasets[0].data.push(latestMetric[`${key}_usage`]);
                }
                chart.update();
            });
        };

        // Chart initialization
        const initializeCharts = async () => {
            const metric = await fetchLatestMetric();
            if (!metric) return null;
            return {
                cpu: initChart('cpuChart', 'line', { label: 'CPU' }, 'top', 'Usage (%)', `CPU`, '%'),
                memory: initChart('memoryChart', 'line', { label: 'Memory' }, 'top', 'Usage (%)', `Memory`, '%'),
                disk: initChart('diskChart', 'line', { label: 'Disk' }, 'top', 'Usage (%)', `Disk`, '%'),
                network: initChart(
                    'networkChart',
                    'line',
                    [{ label: 'Receive' }, { label: 'Transmit' }],
                    'top',
                    'Rate (MB/s)',
                    'Network Rate',
                    'MB/s',
                ),
            };
        };

        // Main execution
        $(document).ready(async function () {
            let charts = await initializeCharts();
            if (!charts) return;

            $('.dropdown-item').click(async function (e) {
                e.preventDefault();
                const timeRange = $(this).data('time');
                const metrics = await fetchMetrics(timeRange);
                if (metrics) {
                    console.log('Raw metrics data:', metrics); // 这行应该会输出
                    updateCharts(charts, metrics);
                }
            });

            let autoRefreshInterval;
            let isAutoRefreshing = false;
            $('#refreshButton').click(function () {
                if (isAutoRefreshing) {
                    clearInterval(autoRefreshInterval);
                    $(this).removeClass('is-info');
                    $(this).find('span:last').text('Auto Refresh');
                    isAutoRefreshing = false;
                } else {
                    $(this).addClass('is-info');
                    $(this).find('span:last').text('Stop Refresh');
                    isAutoRefreshing = true;
                    refreshData();
                    autoRefreshInterval = setInterval(refreshData, 5000);
                }
            });

            async function refreshData() {
                const latestMetric = await fetchLatestMetric();
                if (latestMetric) {
                    addLatestDataToCharts(charts, latestMetric);
                }
            }
        });
    </script>
</div>
